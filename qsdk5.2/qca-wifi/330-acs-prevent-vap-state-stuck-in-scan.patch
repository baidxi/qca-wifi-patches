ACS module state is maintained per-radio. Whenever
an ACS on-chan load report scan is started it is
marked so in the ACS state structure. The load
report can be scheduled by band steering module
depending on configuration. With current
(2018-02-19) cloud setup the interval is 60
seconds between scans.

Scanner module isn't properly locked and
serialized in a couple of places. One of such
places is si_scan_in_progress. It is assigned
false during scan completion before handlers are
run. It is not protected by an ss_lock unlike
during ieee80211_scan_run(). It is only protected
implicitly by being serialized by the scan state
machine. This means scan completion event handlers
can run while another scan is actually starting.

One of the handlers responsible for maintaning vap
state (vap->iv_state) tries to ignore scan events
that are supposedly generated by other modules,
including ACS.

While this makes sense in general the way it is
implemented is wrong. It was possible for ACS scan
to prevent vap scan handler from leaving SCAN
iv_state by changing the ACS var named
acs_scan_report_active. On DA radios (2.4GHz on
Piranha) that led to kernel crash because it
required vap to be not active before it can be
deleted. However it was getting stuck being active
forever because it could never leave SCAN iv_state
and could never transition to INIT state.

The bug was wasy to trigger by starting STA vap
scan and then spamming "iwpriv ap_vap acsreport
2" so that STA vap scan completion would be
quickly followed by an ACS scan.

The kernel would crash with the following message
(note the "vap not stopped" lacking \n) when
trying to destroy STA vap with wlanconfig:

> <4>[ 3641.720418] vap not stoppedKernel bug detected1:
> <4>[ 3641.722801] CPU: 0 PID: 15042 Comm: wlanconfig Tainted: P 4.4.60 #249
> <4>[ 3641.730795] task: 857e0000 ti: 84d24000 task.ti: 84d24000
> [...]
> <4>[ 3641.785793] epc : 863d8598 ath_net80211_update_rate_node+0xfcc/0x256c [qca_da]
> <4>[ 3641.793435] ra : 863d8598 ath_net80211_update_rate_node+0xfcc/0x256c [qca_da]
--- a/umac/include/ieee80211_var.h
+++ b/umac/include/ieee80211_var.h
@@ -2931,6 +2931,7 @@ typedef struct ieee80211vap {
     u_int8_t                   iv_csa_interop_aggr_enabled;
     u_int8_t                   iv_csa_interop_aggr_active;
     u_int8_t                   iv_hide_ssid_state;
+    u_int8_t                   iv_state_is_scanning;
 } IEEE80211VAP, *PIEEE80211VAP;
 
 #if QCN_IE
--- a/umac/mlme/ieee80211_proto.c
+++ b/umac/mlme/ieee80211_proto.c
@@ -79,17 +79,24 @@ static void ieee80211_vap_scan_event_han
      * Ignore notifications received due to scans requested by other modules.
      */
     if (vap != originator) {
+        if (vap->iv_state_is_scanning)
+            goto ignore;
         return;
     }
     /* Ignore offchan scan as it doesn't change the state */
     if(vap->offchan_requestor == event->requestor) {
+        if (vap->iv_state_is_scanning)
+            goto ignore;
         return;
     }
     /* Ignore acs scan report */
     if(wlan_get_param(vap, IEEE80211_START_ACS_REPORT)) {
+        if (vap->iv_state_is_scanning)
+            goto ignore;
         return;
     }
 
+ignore:
     switch(event->type) {
      case IEEE80211_SCAN_STARTED:
          IEEE80211_DPRINTF(vap, IEEE80211_MSG_STATE,
@@ -98,6 +105,7 @@ static void ieee80211_vap_scan_event_han
                            originator, vap,
                            event->scan_id, event->type, event->reason);
 
+         vap->iv_state_is_scanning = 1;
          ieee80211_state_event(vap, IEEE80211_STATE_EVENT_SCAN_START);
          break;
      case IEEE80211_SCAN_COMPLETED:
@@ -110,6 +118,7 @@ static void ieee80211_vap_scan_event_han
 #ifdef QCA_PARTNER_PLATFORM		 
          vap->iv_list_scanning = 0;
 #endif
+         vap->iv_state_is_scanning = 0;
          ieee80211_state_event(vap, IEEE80211_STATE_EVENT_SCAN_END);
          break;
     default:
